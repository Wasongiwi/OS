# Note01

1. ```rust
   let _x = 5;//忽略未被使用的变量
   ```

   

2. Rust支持声明可变的变量，也支持声明不可变的变量，前者为编程提供了灵活性，后者为编程提供了安全性。`mut`关键字

   ```rust
   let mut x = 5;
   ```

3. 常量：不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值；常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

   ```
   const MAX_POINTS: u32 = 100_000;
   ```

4. 基本类型：

   * 数值类型: 有符号整数 (`i8`, `i16`, `i32(default)`, `i64`, `isize`)、 无符号整数 (`u8`, `u16`, `u32`, `u64`, `usize`) 、浮点数 (`f32`, `f64`)、以及有理数、复数
   * 字符串：**字符串字面量**和**字符串切片 `&str`**
   * 布尔类型： `true`和`false`
   * 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
   * 单元类型: 即 `()` ，其唯一的值也是 `()`
   * **任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**：如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。

5. 整型溢出

   1. 当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic
   2. 在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出，会生成做错误的结果

6. ```rust
   for i in 1..=5 {
       println!("{}",i);
   }
   //1 2 3 4 5
   for i in 1..5 {
       println!("{}",i);
   }
   //1 2 3 4
   ```

7. **有分号表示语句，无返回值；无分号为表达式，需要返回值**。

8. 函数

   ```rust
   fn add(i: i32, j: i32) -> i32 {
      i + j
    }
   ```

   * Rust 是强类型语言，因此每一个函数参数都标识出它的具体类型
   * 单元类型`()`
     * 函数没有返回值，那么返回一个 `()`
     * 通过 `;` 结尾的语句返回一个 `()`
   * 当用 `!` 作函数返回类型的时候，表示该函数永不返回( diverge function )

9. 如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：

   - **垃圾回收机制(GC)**，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
   - **手动管理内存的分配和释放**, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
   - **通过所有权来管理内存**，编译器在编译时会根据一系列规则进行检查

   其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。

10. 栈

    * 栈按照顺序存储值并以相反顺序取出值，这也被称作**后进先出**。

    * 增加数据叫做**进栈**，移出数据则叫做**出栈**。

    * 因为上述的实现方式，栈中的所有数据都**必须占用已知且固定大小的内存空间**，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。

11. 堆

    * 与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。

    * 当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的**指针**, 该过程被称为**在堆上分配内存**，有时简称为 “分配”(allocating)。

    * 接着，该指针会被推入**栈**中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的**指针**，来获取数据在堆上的实际内存位置，进而访问该数据。

12. 可变引用：可读可写，`&mut string`，**可变引用同时只能存在一个**

13. 不可变引用：只读`&string`，**可变引用与不可变引用不能同时存在**

14. **悬垂引用**也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。

15. ```rust
    {                      // s 在这里无效，它尚未声明
        let s = "hello";   // 从此处起，s 是有效的
    }                      // 此作用域已结束，s不再有效
    let s = String::from("hello");
    ```

    * `String` 类型是一个复杂类型，由存储在栈中的**堆指针**、**字符串长度**、**字符串容量**共同组成，其中**堆指针**是最重要的，它指向了真实存储字符串内容的堆内存，容量是堆内存分配空间的大小，长度是目前已经使用的大小。
16. **获取变量的引用，称之为借用(borrowing)**

    1. **引用作用域的结束位置从花括号变成最后一次使用的位置**
    2. 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用

    

    

    

    

    

    

    

    

    
